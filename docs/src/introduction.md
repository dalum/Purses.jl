# Introduction

Purses.jl provides a type for wrapping a value that carries a small pre-computed cache around with it.  This kind of wrapped value is here referred to as a purse, and Purses.jl exports a single implementation of it called `Purse`.  A purse effectively functions as a named tuple or a struct, except field access is automatically tied to a specific function call.  That is, a purse of a number with a cached value of the square root of that number will automatically retrieve the cached value, when `sqrt` is called with the purse as argument.  In addition, a large number of base functions have been overloaded to automatically unwrap purses which allows them to seamlessly replace values in many cases.  If you encounter a function that is unsupported, please open an issue or a pull request in the GitHub repository.

The cache in `Purse` is stored as a tuple, and the functions used for caching the entries are saved as a type parameter.  This allows specialising on the function to retrieve the cached value using compile-time constants for indexing into the cache.  Such cache retrieval results in native code that is equivalent to field access of a struct, and thus has minimal overhead.  To achieve this functionality, `@generated` methods are used for cacheable functions.  It is worth noting that this can put a lot of pressure on the compiler, since it will have to compile a new method for each type of purse in use.

If the compiler does not know the type of the purse at compile-time, it will not be able to generate effective code.  Instead, it will fall back to run-time method table lookups to retrieve the cache value, which can be significantly slower than the computation itself.  However, this issue is no worse than for field access of a struct or named tuple, where type stability has equal importance for performance.
